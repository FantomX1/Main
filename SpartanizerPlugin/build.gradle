buildscript {
	repositories {
        jcenter()
		// make it easy to test a snapshot version of goomph
		maven {	url 'https://oss.sonatype.org/content/repositories/snapshots/' }
		// grab dependencies from the gradle plugin portal
		maven { url 'https://plugins.gradle.org/m2/' }
		
		mavenCentral()
	}
	// make sure we don't cache stale snapshot versions
	configurations.all {
		resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
	}
	dependencies {
		// a bunch of eclipse stuff
		classpath "com.diffplug.gradle:goomph:${VER_GOOMPH}"
		// creates a targetplatform
		classpath "org.standardout:bnd-platform:${VER_BND_PLATFORM}"
        // shadow, for creating a fat jar
        classpath "com.github.jengelman.gradle.plugins:shadow:2.0.0"
	}
}

repositories {
    mavenCentral()
    // local eclipse maven (created by Goomph)
    maven {
        url rootProject.file('target.p2/build/p2asmaven/maven')
    }
}
// we need the maven repo from p2
evaluationDependsOn(':target.p2')

//////////
// JAVA //
//////////
apply plugin: 'java'

tasks.withType(JavaCompile) {
	options.encoding = 'UTF-8'
}

// we need this because classes from 'main' refer to classes from 'test'.
// why? GOOD QUESTION
sourceSets.main.java.srcDir 'src/test/java'

sourceCompatibility = VER_JAVA
targetCompatibility = VER_JAVA

// If some test is stuck in a loop, and you can't tell which, uncomment the code
// below to print the test class + method name before invocation.
//test {
//	beforeTest { testDesc ->
//		println "Running test: " + testDesc.getClassName() + " - " + testDesc.getName()
//	}
//}

dependencies {
    // eclipse/p2 dependencies, imported with all the transitive dependencies
	// as maven artifacts.
    def repoDir = project(':target.p2').buildDir.path + "/p2asmaven/maven"

	// TODO this is not good! temporary solution
	// Include all the dependencies imported from p2. exclude problematic ones.
	// requires someone to maintain it.
    new File(repoDir + "/eclipse-deps").eachDir {d ->
        if (d.name.contains('tukaani.xz.source')) return // TODO maybe there is a better way to exclude source packages
		if (d.name.contains('jasper.glassfish')) return // unwanted transitive dependency
		if (d.name.contains('compiler.batch')) return // unwanted transitive dependency
		compile "eclipse-deps:" + d.name + ":+"
    }

	// TODO this is not good as well! temporary solution
    new File(repoDir + "/eclipse-deps-jgit").eachDir {d ->
        compile "eclipse-deps-jgit:" + d.name + ":+"
    }

	// TODO do we need this?
    // add SWT and the appropriate platform-native SWT for building and testing
    compile "eclipse-deps:org.eclipse.swt:+"
    compile "eclipse-deps:org.eclipse.swt.${com.diffplug.common.swt.os.SwtPlatform.getNative()}:+"

    // project dependencies
    compile project(':spartan')
    compile project(':fluent.ly')

    // maven dependencies
    compile "junit:junit:${VER_JUNIT}"
    compile "org.mockito:mockito-all:1.9.5"
}

// Dump everything into the manifest
apply plugin: 'osgi'
// configure the OSGi bundle
jar.manifest.attributes(
		'-exportcontents': 'il.org.spartan.*',
		'-removeheaders': 'Bnd-LastModified,Bundle-Name,Created-By,Tool,Private-Package,Require-Capability',
		'-importcontents': '*',
		'Bundle-SymbolicName': project.name,
		'Bundle-RequiredExecutionEnvironment': 'JavaSE-1.8',
		'Require-Capability': 'osgi.ee;filter:="(&(osgi.ee=JavaSE)(version=1.8))"',
		'Bundle-Vendor': 'il.org.spartan',
        'Bundle-Version': '1.0.0',
		'Bundle-License': "http://www.apache.org/licenses/LICENSE-2.0"
)

/////////////
// FAT JAR //
/////////////
// Make a jar that contains the maven dependencies
apply plugin: 'com.github.johnrengelman.shadow'

def projectDependencies = project.configurations.runtime.getAllDependencies()
shadowJar {
    dependencies {
        exclude(dependency("eclipse-deps:.*:.*"))
    }
}
