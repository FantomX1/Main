package il.org.spartan.Leonidas.plugin.leonidas;

import com.intellij.psi.PsiElement;
import il.org.spartan.Leonidas.auxilary_layer.az;
import il.org.spartan.Leonidas.auxilary_layer.iz;
import il.org.spartan.Leonidas.auxilary_layer.step;
import il.org.spartan.Leonidas.plugin.EncapsulatingNode;

import java.util.*;
import java.util.stream.Collectors;

/**
 * A class responsible for the logic of matching the tree of the user to the definition of the tipper and extracting the
 * correct information of the tree of the user for the sake of future replacing.
 * @author michalcohen
 * @since 31-03-2017.
 */
public class Matcher2 {

    private EncapsulatingNode root;
    private Map<Integer, List<Constraint>> constrains = new HashMap<>();

    public Matcher2() {
        root = null;
    }

    public Matcher2(EncapsulatingNode r) {
        root = r;
    }

    /**
     * @param treeTemplate - the template tree generated by the TreeBuilder
     * @param treeToMatch  - the tree generated by the users' code
     * @return - true iff these two trees match by the Leonidas language.
     */
    @SuppressWarnings("ConstantConditions")
    public static boolean treeMatch(EncapsulatingNode treeTemplate, EncapsulatingNode treeToMatch) {
        if (!iz.conforms(treeToMatch.getInner(), treeTemplate.getInner())
                || iz.block(treeToMatch.getInner()) && !iz.genericBlock(treeTemplate.getInner())
                && treeTemplate.getInner().getUserData(KeyDescriptionParameters.NO_OF_STATEMENTS) != null
                && treeTemplate.getInner().getUserData(KeyDescriptionParameters.NO_OF_STATEMENTS)
                .notConforms(az.block(treeToMatch.getInner()).getStatements().length)
                && treeTemplate.getInner().getUserData(KeyDescriptionParameters.NO_OF_STATEMENTS) != null
                && treeTemplate.getInner().getUserData(KeyDescriptionParameters.NO_OF_STATEMENTS)
                .notConforms(az.block(treeToMatch.getInner()).getStatements().length))
            return false;
        boolean res = true;
        if (treeTemplate.getAmountOfNoneWhiteSpaceChildren() < treeToMatch.getAmountOfNoneWhiteSpaceChildren()
                && !iz.generic(treeTemplate.getInner()))
            return false;
        for (EncapsulatingNode.Iterator treeTemplateChild = treeTemplate.iterator(), treeToMatchChild = treeToMatch
                .iterator(); treeTemplateChild.hasNext()
                     && treeToMatchChild.hasNext(); treeTemplateChild.next(), treeToMatchChild.next())
            res &= treeMatch(treeTemplateChild.value(), treeToMatchChild.value());
        return res;
    }

    public Map<Integer, List<Constraint>> getMap() {
        return constrains;
    }

    public EncapsulatingNode getRoot() {
        return root;
    }

    public void setRoot(EncapsulatingNode n) {
        root = n;
    }

    /**
     * Adds a constraint on a generic element inside the tree of the root.
     *
     * @param id - the id of the element that we constraint.
     * @param c  - the constraint
     */
    public void addConstraint(Integer id, Constraint c) {
        constrains.putIfAbsent(id, new LinkedList<>());
        constrains.get(id).add(c);
    }

    /**
     * @return the matcher elements in all the constraints applicable on the root of this matcher.
     */
    public List<Matcher2> getConstraintsMatchers() {
        return constrains.values().stream()
                .flatMap(Collection::stream)
                .collect(Collectors.toList())
                .stream()
                .map(t -> t.getMatcher())
                .collect(Collectors.toList());
    }

    /**
     * @param e the tree of the user
     * @return true iff the tree of the user matcher the root and holds through all the constraints.
     */
    public boolean match(PsiElement e) {
        Map<Integer, PsiElement> info = extractInfo(root, e);
        return treeMatch(root, EncapsulatingNode.buildTreeFromPsi(e)) && info.keySet().stream()
                .allMatch(id -> constrains.getOrDefault(id, new LinkedList<>()).stream().allMatch(c -> c.match(info.get(id))));
    }

    /**
     * @param treeTemplate - The root of a tree already been matched.
     * @param treeToMatch  - The patterns from which we extract the IDs
     * @return a mapping between an ID to a PsiElement
     */
    public Map<Integer, PsiElement> extractInfo(EncapsulatingNode treeTemplate, PsiElement treeToMatch) {
        Map<Integer, PsiElement> mapping = new HashMap<>();
        EncapsulatingNode.Iterator treeTemplateChile = treeTemplate.iterator();
        for (PsiElement treeToMatchChild = treeToMatch.getFirstChild(); treeTemplateChile.hasNext() && treeToMatchChild != null; treeTemplateChile.next(), treeToMatchChild = step.nextSibling(treeToMatchChild))
			if (treeTemplateChile.value().getInner().getUserData(KeyDescriptionParameters.ID) == null)
				mapping.putAll(extractInfo(treeTemplateChile.value(), treeToMatchChild));
			else
				mapping.put(treeTemplateChile.value().getInner().getUserData(KeyDescriptionParameters.ID),
						treeToMatchChild);
        return mapping;
    }

    /**
     * @param treeToMatch - The patterns from which we extract the IDs
     * @return a mapping between an ID to a PsiElement
     */
    public Map<Integer, PsiElement> extractInfo(PsiElement treeToMatch) {
        return extractInfo(root, treeToMatch);
    }

    /**
     * @return list of Ids of all the generic elements in the tipper.
     */
    public Set<Integer> getGenericElements() {
        final Set<Integer> tmp = new HashSet<>();
        root.accept(e -> {
            if (iz.generic(e.getInner())) {
                tmp.add(e.getInner().getUserData(KeyDescriptionParameters.ID));
            }
        });
        return tmp;
    }

}

