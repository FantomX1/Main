package il.org.spartan.Leonidas.plugin.leonidas;

import com.intellij.psi.PsiElement;
import il.org.spartan.Leonidas.auxilary_layer.az;
import il.org.spartan.Leonidas.auxilary_layer.iz;
import il.org.spartan.Leonidas.auxilary_layer.step;
import il.org.spartan.Leonidas.plugin.leonidas.BasicBlocks.AnyNumberOf;
import il.org.spartan.Leonidas.plugin.leonidas.BasicBlocks.Encapsulator;
import il.org.spartan.Leonidas.plugin.leonidas.BasicBlocks.Optional;

import java.util.*;
import java.util.stream.Collectors;


/**
 * A class responsible for the logic of matching the tree of the user to the definition of the tipper and extracting the
 * correct information of the tree of the user for the sake of future replacing.
 * It is based on the algorithm of SNOBOL4 language pattern matching, and is consistent with the definitions of the bead
 * diagram.
 * @author michalcohen
 * @since 31-03-2017.
 */
public class Matcher {

    private final Map<Integer, List<Constraint>> constrains = new HashMap<>();
    private Encapsulator root;

    public Matcher() {
        root = null;
    }

    public Matcher(Encapsulator r, Map<Integer, List<Constraint>> map) {
        root = r;
        buildMatcherTree(this, map);
    }

    /**
     * @param treeTemplate the template tree.
     * @return a list of all optional elements in the tree.
     */
    private List<Optional> getOptionals(Encapsulator treeTemplate) {
        List<Optional> l = new ArrayList<>();
        treeTemplate.accept(n -> {
            if (iz.optional(n)) {
                l.add(az.optional(n));
            }
        });
        return l;
    }

    /**
     * DO NOT PANIC!
     *
     * @param treeTemplate template tree
     * @param treeToMatch  the tree of the user
     * @param i            the current index of the optional element
     * @param l            a list of all optional elements
     * @param m            an assignment of optional states
     * @return an assignment of optional states that reached a match, or null if the tree of the user doesn't match
     */
    public Map<Optional, Boolean> matchMaker(Encapsulator treeTemplate, Encapsulator treeToMatch, int i, List<Optional> l, Map<Optional, Boolean> m) {
        if (i == l.size()) {
            return matchAssignmentTree(treeTemplate, treeToMatch, m) ? m : null;
        }
        m.put(l.get(i), true);
        Map<Optional, Boolean> b1 = matchMaker(treeTemplate, treeToMatch, i + 1, l, m);
        m.put(l.get(i), false);
        Map<Optional, Boolean> b2 = matchMaker(treeTemplate, treeToMatch, i + 1, l, m);
        return b1 != null ? b1 : b2;
    }

    /**
     * @param treeTemplate template tree
     * @param treeToMatch  the tree of the user
     * @param m            an assignment of optional states
     * @return true iff the treeTemplate under the assignment m matches treeToMatch
     */
    private boolean matchAssignmentTree(Encapsulator treeTemplate, Encapsulator treeToMatch, Map<Optional, Boolean> m) {
        m.forEach(Optional::setActivate);
        return machUntilNextQuantifier(treeTemplate, treeToMatch);
    }

    /**
     * @param treeTemplate - the template tree generated by the TreeBuilder
     * @param treeToMatch  - the tree generated by the users' code
     * @return - true iff these two trees match by the Leonidas language.
     */
    @SuppressWarnings("ConstantConditions")
    private boolean machUntilNextQuantifier(Encapsulator treeTemplate, Encapsulator treeToMatch) {
        Encapsulator.Iterator needle = treeTemplate.iterator(), cursor = treeToMatch.iterator();
        return machUntilNextQuantifier(treeTemplate.iterator(), treeToMatch.iterator());
    }

    private boolean scaryRecur(Encapsulator.Iterator needle, Encapsulator.Iterator cursor) {
        Encapsulator.Iterator bgNeedle = needle.clone(), bgCursor = cursor.clone();
        Encapsulator.Iterator varNeedle = needle.clone(), varCursor = cursor.clone();
        if (iz.optional(needle.value())) {
            varNeedle.setNumberOfOccurrences(0);
            boolean b = matchQuantifier(varNeedle, varCursor) && scaryRecur(varNeedle, varCursor);
            if (!b) {
                varNeedle.setNumberOfOccurrences(0);
                varNeedle = bgNeedle.clone();
                varCursor = bgCursor.clone();
                return matchQuantifier(varNeedle, varCursor) && scaryRecur(varNeedle, varCursor);
            }
        }
        return true;
    }

    private boolean matchBead(Encapsulator.Iterator needle, Encapsulator.Iterator cursor) {
        for (; needle.hasNext() && cursor.hasNext() && !iz.quantifier(needle.value()); needle.next(), cursor.next()) {
            if (!iz.conforms(needle.value(), cursor.value()))
                return false;

        }
    }


    private int findOccurrencesOfAnyNumberOf(AnyNumberOf eno, Encapsulator.Iterator cursor) {
        int s = 0;
        for (Encapsulator.Iterator bgCursor = cursor.clone(); eno.conforms(bgCursor.value().getInner()); bgCursor.next(), s++)
            ;
        return s;
    }

    private boolean matchQuantifier(Encapsulator.Iterator needle, Encapsulator.Iterator cursor) {
        return true;
    }

    /**
     * @param treeTemplateIt - the iterator of template tree generated by the TreeBuilder
     * @param treeToMatchIt  - the iterator of tree generated by the users' code
     * @return - true iff these two trees match by the Leonidas language.
     */
    @SuppressWarnings("ConstantConditions")
    private boolean machUntilNextQuantifier(Encapsulator.Iterator treeTemplateIt, Encapsulator.Iterator treeToMatchIt) {
        if (!iz.conforms(treeToMatch, treeTemplateIt.value()))
            return false;
        boolean res = true;
        if (treeTemplateIt.hasNext() ^ treeToMatchIt.hasNext())
            return false;
        for (Encapsulator.Iterator treeTemplateChild = treeTemplate.iterator(), treeToMatchChild = treeToMatch
                .iterator(); treeTemplateChild.hasNext() && treeToMatchChild.hasNext();
             treeTemplateChild.next(), treeToMatchChild.next()) {
            res &= machUntilNextQuantifier(treeTemplateChild.value(), treeToMatchChild.value());
        }
        return res;
    }

    /**
     * @param matcher builds recursively the matchers for the constraints that are relevant to the current matcher.
     * @param map a mapping between id of generic elements and lists of constraints.
     */
    private void buildMatcherTree(Matcher matcher, Map<Integer, List<Constraint>> map) {
        Set<Integer> l = matcher.getGenericElements();
        l.forEach(i -> java.util.Optional.ofNullable(map.get(i)).ifPresent(z -> z.forEach(j ->
                matcher.addConstraint(i, j))));
        matcher.getConstraintsMatchers().forEach(im -> buildMatcherTree(im, map));
    }

    public Encapsulator getRoot() {
        return root;
    }

    private void setRoot(Encapsulator n) {
        root = n;
    }

    /**
     * Adds a constraint on a generic element inside the tree of the root.
     *
     * @param id - the id of the element that we constraint.
     * @param c  - the constraint
     */
    private void addConstraint(Integer id, Constraint c) {
        constrains.putIfAbsent(id, new LinkedList<>());
        constrains.get(id).add(c);
    }

    /**
     * @return the matcher elements in all the constraints applicable on the root of this matcher.
     */
    private List<Matcher> getConstraintsMatchers() {
        return constrains.values().stream()
                .flatMap(Collection::stream)
                .collect(Collectors.toList())
                .stream()
                .map(Constraint::getMatcher)
                .collect(Collectors.toList());
    }

    /**
     * @param e the tree of the user
     * @return true iff the tree of the user matcher the root and holds through all the constraints.
     */
    public boolean match(PsiElement e) {
        List<Optional> l = getOptionals(root);
        Map<Optional, Boolean> res = matchMaker(root, Encapsulator.buildTreeFromPsi(e), 0, l, new HashMap<>());
        if (res == null) return false;
        res.forEach(Optional::setActivate);
        Map<Integer, PsiElement> info = extractInfo(root, e);

        return info.keySet().stream()
                .allMatch(id -> constrains.getOrDefault(id, new LinkedList<>()).stream().allMatch(c -> c.match(info.get(id))));
    }

    /**
     * @param treeTemplate - The root of a tree already been matched.
     * @param treeToMatch  - The patterns from which we extract the IDs
     * @return a mapping between an ID to a PsiElement
     */
    private Map<Integer, PsiElement> extractInfo(Encapsulator treeTemplate, PsiElement treeToMatch) {
        Map<Integer, PsiElement> mapping = new HashMap<>();
        Encapsulator.Iterator treeTemplateChile = treeTemplate.iterator();
        for (PsiElement treeToMatchChild = treeToMatch.getFirstChild(); treeTemplateChile.hasNext() && treeToMatchChild != null; treeTemplateChile.next(), treeToMatchChild = step.nextSibling(treeToMatchChild))
            if (treeTemplateChile.value().getUserData(KeyDescriptionParameters.ID) == null)
                mapping.putAll(extractInfo(treeTemplateChile.value(), treeToMatchChild));
			else
                mapping.put(treeTemplateChile.value().getUserData(KeyDescriptionParameters.ID),
                        treeToMatchChild);
        return mapping;
    }

    /**
     * @param treeToMatch - The patterns from which we extract the IDs
     * @return a mapping between an ID to a PsiElement
     */
    public Map<Integer, PsiElement> extractInfo(PsiElement treeToMatch) {
        List<Optional> l = getOptionals(root);
        Map<Optional, Boolean> res = matchMaker(root, Encapsulator.buildTreeFromPsi(treeToMatch), 0, l, new HashMap<>());
        assert res != null;
        res.forEach(Optional::setActivate);
        return extractInfo(root, treeToMatch);
    }

    /**
     * @return list of Ids of all the generic elements in the tipper.
     */
    private Set<Integer> getGenericElements() {
        final Set<Integer> tmp = new HashSet<>();
        root.accept(e -> {
            if (iz.generic(e)) {
                tmp.add(e.getInner().getUserData(KeyDescriptionParameters.ID));
            }
        });
        return tmp;
    }

    /**
     * Represents a constraint on a generalized variable of the leonidas language.
     *
     * @author michalcohen
     * @since 01-04-2017.
     */
    public static class Constraint {

        private final ConstraintType type;
        private final Matcher matcher;

        public Constraint(ConstraintType t, Encapsulator e) {
            type = t;
            matcher = new Matcher();
            matcher.setRoot(e);
        }

        public ConstraintType getType() {
            return type;
        }

        public Matcher getMatcher() {
            return matcher;
        }

        /**
         * @param e the users tree to match.
         * @return indication of e being matched recursively to the matcher, when taking in consideration the type of the constraint.
         */
        public boolean match(PsiElement e) {
            return (type == ConstraintType.IS && matcher.match(e)) || (type == ConstraintType.IS_NOT && !matcher.match(e));
        }

        public enum ConstraintType {
            IS,
            IS_NOT
        }
    }
}

