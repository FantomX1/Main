package il.org.spartan.ispartanizer.plugin.leonidas;

import com.intellij.psi.PsiElement;
import il.org.spartan.ispartanizer.auxilary_layer.az;
import il.org.spartan.ispartanizer.auxilary_layer.iz;
import il.org.spartan.ispartanizer.auxilary_layer.step;

import java.util.HashMap;
import java.util.Map;

/**
 * This class find matches between template tree to a tree generated by
 * the users' code.
 *
 * @author AnnaBel7 and michal cohen
 * @since 06-01-2017.
 */
public class PsiTreeMatcher {

    /**
     * @param treeTemplate - the template tree generated by the TreeBuilder
     * @param treeToMatch  - the tree generated by the users' code
     * @return - true iff these two trees match by the Leonidas language.
     */
    public static boolean match(PsiElement treeTemplate, PsiElement treeToMatch) {
        if (!iz.conforms(treeToMatch, treeTemplate)) {
            return false;
        }
        // many more conditions will be added once more constrains are defined
        if (iz.block(treeToMatch)) {
            if (treeTemplate.getUserData(KeyDescriptionParameters.NO_OF_STATEMENTS) != null && treeTemplate.getUserData(KeyDescriptionParameters.NO_OF_STATEMENTS).notConforms(az.block(treeToMatch).getStatements().length)) {
                return false;
            }
        }
        boolean res = true;
        PsiElement treeTemplateChild, treeToMatchChild;
        for (treeTemplateChild = treeTemplate.getFirstChild(),
                     treeToMatchChild = treeToMatch.getFirstChild();
             treeTemplateChild != null && treeToMatchChild != null;
             treeTemplateChild = step.nextSibling(treeTemplateChild),
                     treeToMatchChild = step.nextSibling(treeToMatchChild)) {
            res = res && match(treeTemplateChild, treeToMatchChild);
        }
        return treeTemplateChild == null && (treeToMatchChild == null || iz.generic(treeTemplate)) && res;
    }

}
