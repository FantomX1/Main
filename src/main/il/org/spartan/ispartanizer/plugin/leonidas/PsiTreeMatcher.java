package il.org.spartan.ispartanizer.plugin.leonidas;

import com.intellij.psi.PsiElement;
import il.org.spartan.ispartanizer.auxilary_layer.az;
import il.org.spartan.ispartanizer.auxilary_layer.iz;
import il.org.spartan.ispartanizer.auxilary_layer.step;

import java.util.HashMap;
import java.util.Map;

//import static il.org.spartan.ispartanizer.plugin.leonidas.PsiDescriptionParameters.*;

/**
 * This class find matches between template tree to a tree generated by
 * the users' code.
 *
 * @author AnnaBel7 and michal cohen
 * @since 06-01-2017.
 */
public class PsiTreeMatcher {

    /**
     * @param treeTemplate - the template tree generated by the TreeBuilder
     * @param treeToMatch  - the tree generated by the users' code
     * @return - true iff these two trees match by the Leonidas language.
     */
    public static boolean match(PsiElement treeTemplate, PsiElement treeToMatch) {
        if (!iz.theSameType(treeToMatch, treeTemplate)) {
            return false;
        }
        // many more conditions will be added once more constrains are defined
        if (iz.block(treeToMatch)) {
            if (treeTemplate.getUserData(KeyDescriptionParameters.NO_OF_STATEMENTS)
                    .notConforms(az.block(treeToMatch).getStatements().length)) {
                return false;
            }
        }
        boolean res = true;
        for (PsiElement treeTemplateChild = treeTemplate.getFirstChild(),
             treeToMatchChild = treeToMatch.getFirstChild();
             treeTemplateChild != null && treeToMatchChild != null;
             treeTemplateChild = step.nextSibling(treeTemplateChild),
                     treeToMatchChild = step.nextSibling(treeToMatchChild)) {
            res = res && match(treeTemplateChild, treeToMatchChild);
        }
        return res;
    }

    /**
     * @param treeTemplate - The root of a tree already been matched.
     * @param treeToMatch  - The patterns from which we extract the IDs
     * @return a mapping between an ID to a PsiElement
     */
    public static Map<Integer, PsiElement> extractInfo(PsiElement treeTemplate, PsiElement treeToMatch) {
        Map<Integer, PsiElement> mapping = new HashMap<>();
        for (PsiElement treeTemplateChild = treeTemplate.getFirstChild(), treeToMatchChild = treeToMatch.getFirstChild(); treeTemplateChild != null && treeToMatchChild != null; treeTemplateChild = step.nextSibling(treeTemplateChild), treeToMatchChild = step.nextSibling(treeToMatchChild)) {
            if (treeTemplateChild.getUserData(KeyDescriptionParameters.ORDER) != null) {
                mapping.put(treeTemplateChild.getUserData(KeyDescriptionParameters.ORDER), treeToMatchChild);
            }
        }
        return mapping;
    }

}
